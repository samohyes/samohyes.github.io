---
title: 'Malware analysis: Inline hooking(PMA-11-02)'
date: 2017-12-02 21:32:32
author: xudong
tags:
- Malware analysis
- 2017
- Windows malware
---
This sample is from <b><i>Practical Malware analysis</i></b> Lab 11-02. Mainly it’s doing inline hooking.
 
<h3><b><u>Quick Background</u></b></h3>
So let’s talk about inline hooking first. According to the PMA, inline hooking changes the actual function code. Basically, it replace the start of the code with a jump to the malicious code from the rootkit. After that, it will return back to the normal function to make sure everything goes well. PMA gives a good example for this. But I am pretty sure after reading this sample,  we will have a really deep understanding of inline hook.
 
<h3><b><u>Static Analysis</u></b></h3>
Let’s check our file first. The .ini file just contains a string which we don’t know what it means. You can probably assume it’s a password or something. But we can just head to the .dll now. Let’s use string.exe to check whether there are some interesting strings. We see some interesting ones:
 
&#149;   <b><i>SOFTWARE\Microsoft\Widows NT\CurrentVersion\Windows</i></b>
&#149;   <b><i>AppInit_DLLs</i></b>
This two must have something to do with the registry. Probably help the malware to stay persistence.
&#149;   <b><i>Spoolvxx32.dll</i></b>
&#149;   <b><i>Send    wsock32.dll</i></b>
This two might do something with internet.
&#149;   <b><i>Lab11-02.ini</i></b>
It must do something with that mysterious string, right?
&#149;   <b><i>THEBAT.EXE OUTLOOK.EXE MSIMN.EXE</i></b>
Might be some applications.
 
Ok, then we use CFF to see the PE structure.
We find that the .dll has an export function named installer. For the import directory we see that ReadFile, CreateFile. Not too much information here.
 
<h3><b><u>Dynamic Analysis</u></b></h3>
Let’s use the regshot and process monitor. Well, according to the regshot, we see there is a value modified:
<b><i>HKLM\SOFTWARE\Microsoft\WidowsNT\CurrentVersion\Windows\AppInit_DLLs</i></b>
 
And the value added is spoolvxx32.dll.Ok, this is how the malware manage to stay persistence. AppInit_DLLs will be loaded into every process that loads User32.dll. Normally, malware authors need to check the process name to determine they will run their payload. In this case, you probably will know that the string that we found, <b><i>“THEBAT.EXE OUTLOOK.EXE MSIMN.EXE”</i></b>, might be that check process. But if you don’t, no need to worry. To be honest, I didn’t figure it out when I am at this stage.
 
Then, what is the spoolvxx32? Ok, through Process monitor we can probably find something. We see this log:
<b><i>CreateFile C:\Windows\system32\spoolvxx32.dll</i></b>
So this is the one added to AppInit_DLL. We can use the winmd5 to examine the <b><i>spoolvxx32.dll</i></b> and the <b><i>Lab11-02.dll</i></b>. And it turns out they have the same md5 value.
 
Ok, until now, there are still something that we are not clear. We have this <b><i>“send wsock32.dll”</i></b> and <b><i>“THEBAT.EXE OUTLOOK.EXE MSIMN.EXE”</i></b>. We don’t know what is that doing. So let’s go to a more advanced analysis which will show us the inline hooking it does!
 
<h3><b><u>Advanced analysis</u></b></h3>
Let’s use the IDA to open that .dll file. At the DLLmain, we can see this branch.

{% asset_img 1.png %}

The code highlighted with yellow is the Getsystemdirectory call which will give us the system32 path. And we see that <b><i>‘strncat’</i></b> which add the <b><i>‘\\lab11-02.dll’</i></b> to the system32 path. After that, it calls CreateFile. Actually, we have to make it clear that here CreateFile is not what we mean by create file. Here it’s creating an object in kernel which is more like open a file. This is something that really bothers me at first.

{% asset_img 2.png %}

After it opens the file, it just reads the string in the file and do something. There is a function here which is <b><i>sub_100010B3</i></b>, after we double click the function, we see some complicated code. But what I would assume is that it’s some kind of decoding function.
 
Let’s examine it in OllyDbg. But before doing this, make sure that we put the .ini file in the system directory. We see that the address for this call is 100016CA so  set a breakpoint at this address. And after we run the call we can see that in eax, there is a string which is an email address.

{% asset_img 3.png %}

Therefore, our assumption is right. The call is just a decoding function and you guys can try to reverse that function if you want.
 
Ok, now let’s go deeper. We see that after the readfile and closehandle, it calls <b><i>sub_100014B6</i></b>. This must the place that the malware actually do something. Double click it. We come to this place.

{% asset_img 4.png %}

First, there are two calls, <b><i>Sub_10001075</i></b> and <b><i>Sub_10001104</i></b>, which gets the process the name that the malicious dll attached to. So in our case, this should be <b><i>LOADDLL.EXE</i></b> because we are using the OllyDbg. So later, this malware checks whether the process name is any of <b><i>“THEBAT.EXE OUTLOOK.EXE MSIMN.EXE”</i></b>. If it’s any of this, it will jump to this piece of code.

{% asset_img 5.png %}

There are 3 calls here. For the <b><i>sub_100013BD</i></b>, if you dig deeper into it, you will find a function call for <b><i>suspendthread</i></b>. And for the <b><i>sub_10001499</i></b>, you will find a function call for <b><i>resumethread</i></b>. You can even dig much deeper to see how it suspend and resume the threads. But for now, we will stop here and turn to the call <b><i>sub_100012A3</i></b>.

And according to the four arguments that it pass in, we change the names of the variables at first which will show like this.

{% asset_img 6.png %}

This will definitely give you a lot convenience. In this piece of code, it mainly use the <b><i>GetProcessAddress</i></b> to get the address of send function. Then it goes to this piece of code.

{% asset_img 7.png %}

Oh,it finally pass in this send_address, it must be doing something real now!!! Otherwise, I will break down!!!

{% asset_img 8.png %}

Oh, what’s it doing here? No annotation at all! Don’t worry. We change the variable name to make it more clearly. It just calculate the difference between the address of <b><i>sub_1000113D</i></b> and the <b><i>send_address</i></b>. It then subtract it by 5 and move it into var_4. Here 5 is the size of the code of jump ***. Then later it must add the opcode of the “jump” and the address of the hook function to the original send function. So let’s scroll down and find it.

{% asset_img 9.png %}

I use two rectangles to make it clear. How you can’t just change that 5 bytes, right? You must make sure that 5 bytes are still there when we later do something malicious and come back. So it can operate well otherwise it will break down and the victim will know he is attacked! So the malware must save that first 5 bytes somewhere. Before we come to that, we change the <b><i>var_8</b></i> to trampoline. This is what PMA did, because <b><i>var_8</i></b> stores the start of the code that solve the problem we just mentioned.

{% asset_img 10.png %}

Hi, hold on, dude. We are nearly done. Clearly, the first part is to set out a place for the trampoline function. The second part is to copy the first 5 bytes of send function into the trampoline. The third part is to pass the address if the trampoline into the variable <b><i>dword_10003484</i></b>. Ok, then let’s see the hook function which is at <b><i>1000113D</i></b>.
 
Actually what happens here is much easier. It just check whether there is the <b><i>“RCPT TO:”</i></b> in memory. If it’s there. it will add the email that we just find to the recipient list.
 
Ok, now, we are finalllllllllllllllly done!!!!!!!
 
Any question, please contact me at <b><i>xudong_shao@hotmail.com</i></b>